<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Options Detail</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        .table-container { margin-top: 20px; width: calc(75%);}
        .filter-container { margin-bottom: 20px; display: flex; justify-content: space-between; flex-wrap: wrap; }
        .filter-group { margin-bottom: 10px; }
        .graph-and-details-container { display: flex; margin-top: 10px; justify-content: center; }
        .graph-container { flex: 2; margin-right: 10px; height: 600px; width: 60%; display: none; text-align: center; }
        .details-table {  
            flex: 1; 
            width: 30%; 
            margin-left: 1px; 
            border: 1px solid #ccc; 
            background-color: #f9f9f9; 
            display: none; /* Hidden initially */
            text-align: left;
        }
        .strategy-details-table {
            width: 100%; /* Make the details table fill the side panel */
            border: 1px solid #ccc;
            background-color: #f9f9f9;
            padding: 10px;
            box-sizing: border-box;
        }
        .glow {
            box-shadow: 0 0 15px #00ff00;  /* Glowing green */
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        table, th, td {
            border: 1px solid black;
            padding: 10px;
            text-align: left;
        }

        /* Responsive layout when strategy builder is present */
        .main-content {
            width: 70%; /* Adjust width to make room for the strategy builder */
            display: inline-block;
            vertical-align: top;
            margin-top: 60px;
        }

        .strategy-container {
            width: 25%; /* Adjust the width of the strategy container */
            height: 100%; /* Make sure it stretches */
            position: fixed; /* Stay on the side */
            right: 0;
            top: 60px;
            background-color: #f9f9f9;
            padding: 10px;
            box-shadow: -2px 0 5px rgba(0,0,0,0.1); /* Add a shadow for visibility */
            overflow-y: auto; /* Enable vertical scrolling */
        }

        /* Strategy builder hidden initially */
        .strategy-container.hidden {
            display: none;
        }
        
    </style>
</head>
<body>
    {% extends 'base.html' %}

    {% block title %}Options for {{ ticker }}{% endblock %}

    {% block content %}
    <div class="container">
      <div class="main-content">
        <h1 class="mt-4">{{ ticker }} Options</h1>
        
        <!-- Filter Section -->
        <div class="filter-container">
          <div class="filter-group">
            <label for="expiration-date">Expiration Date:</label>
            <select id="expiration-date" class="form-control">
              {% for date in expiration_dates %}
                <option value="{{ date }}">{{ date }}</option>
              {% endfor %}
            </select>
          </div>
          <div class="filter-group">
            <label for="strike-range">Strike Price Range:</label>
            <input type="number" id="strike-min" class="form-control" placeholder="Min Strike">
            <input type="number" id="strike-max" class="form-control" placeholder="Max Strike">
          </div>
          <div class="filter-group">
            <label for="option-type">Option Type:</label>
            <select id="option-type" class="form-control">
              <option value="both">Both</option>
              <option value="call">Calls</option>
              <option value="put">Puts</option>
            </select>
          </div>
          <div class="filter-group">
            <button id="apply-filters" class="btn btn-primary">Apply Filters</button>
          </div>
        </div>

        <!-- Calls Options Table -->
        <div class="table-container">
          <h3>Call Options</h3>
          <table class="table table-striped">
            <thead>
              <tr>
                <th>Contract Name</th>
                <th>Last Trade Date</th>
                <th>Strike</th>
                <th>Last Price</th>
                <th>Bid</th>
                <th>Ask</th>
                <th>Change</th>
                <th>% Change</th>
                <th>Volume</th>
                <th>Open Interest</th>
                <th>Implied Volatility</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="calls-table-body">
              <!-- Call options will be loaded here -->
            </tbody>
          </table>
        </div>

        <!-- Puts Options Table -->
        <div class="table-container">
          <h3>Put Options</h3>
          <table class="table table-striped">
            <thead>
              <tr>
                <th>Contract Name</th>
                <th>Last Trade Date</th>
                <th>Strike</th>
                <th>Last Price</th>
                <th>Bid</th>
                <th>Ask</th>
                <th>Change</th>
                <th>% Change</th>
                <th>Volume</th>
                <th>Open Interest</th>
                <th>Implied Volatility</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="puts-table-body">
              <!-- Put options will be loaded here -->
            </tbody>
          </table>
        </div>

        <!-- Placeholder for Expandable Graph and Details Section -->
        <template id="expandable-template">
          <div class="graph-and-details-container">
            <!-- Graph Container -->
            <div class="graph-container"></div>
            
            <!-- Individual Option Details Table -->
            <div class="details-table">
              <h4>Details</h4>
              <table>
                <tr><td><strong>Max Profit:</strong></td><td class="max-profit"></td></tr>
                <tr><td><strong>Max Loss:</strong></td><td class="max-loss"></td></tr>
                <tr><td><strong>Breakeven Stock Price:</strong></td><td class="breakeven-price"></td></tr>
                <tr><td><strong>Current Stock Price:</strong></td><td class="current-stock-price">Hover over graph</td></tr>
              </table>
            </div>
          </div>
        </template>
      </div>

      <!-- Strategy Builder -->
      <div class="strategy-container hidden" id="strategyContainer">
        <h4>Strategy Details</h4>

        <div class="form-group">
            <label for="strategy-name">Strategy Name:</label>
            <input type="text" class="form-control" id="strategy-name" placeholder="Enter a name for your strategy">
        </div>

        <table class="strategy-details-table">
          <tr><td><strong>Max Profit:</strong></td><td class="strategy-max-profit"></td></tr>
          <tr><td><strong>Max Loss:</strong></td><td class="strategy-max-loss"></td></tr>
          <tr><td><strong>Breakeven Stock Prices:</strong></td><td class="strategy-breakeven-prices"></td></tr>
          <tr><td><strong>Current Stock Price:</strong></td><td class="strategy-current-stock-price">Hover over graph</td></tr>
        </table>

        <div id="strategyGraph" style="width: 100%; height: 300px; margin-top: 20px;"></div>

        <button id="buyStrategyBtn" class="btn btn-success" onclick="buyStrategy()">Buy Strategy</button>

        <!-- List of Contracts in Strategy -->
        <h5>Contracts in Strategy:</h5>
        <table id="strategyContractsTable" style="width:100%; margin-top: 10px;">
            <thead>
            <tr>
                <th>Contract Symbol</th>
                <th>Strike</th>
                <th>Option Type</th>
                <th>Expiration</th>
            </tr>
            </thead>
            <tbody id="strategyContractsBody">
        <!-- Contracts will be added here dynamically -->
            </tbody>
        </table>

        <!-- Buy Strategy Button -->
      </div>
    </div>

        

    <script>
      let strategy = [];  // This will store the contracts added to the strategy
      let addedContracts = new Set();  // Store added contract symbols to track toggles

      function toggleStrategyVisibility(show) {
          const strategyContainer = document.getElementById('strategyContainer');
          const mainContent = document.querySelector('.main-content');
          
          if (show) {
              strategyContainer.classList.remove('hidden');
              mainContent.style.width = '70%';  // Adjust main content width when strategy builder is shown
          } else {
              strategyContainer.classList.add('hidden');
              mainContent.style.width = '100%'; // Full width when strategy builder is hidden
          }
      }


      function addToCart(contractSymbol, strike, optionType, expiration, action) {
        const cartItem = {
            type: 'option',
            contract: contractSymbol,
            strike: strike,
            option_type: optionType,
            expiration: expiration,
            action: action
        };

        fetch('/add_to_cart', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(cartItem)
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                alert('Item added to cart successfully!');
            } else {
                alert('Failed to add item to cart.');
            }
        })
        .catch(error => {
            console.error('Error adding item to cart:', error);
        });
    }



      document.getElementById('apply-filters').addEventListener('click', function() {
        const ticker = '{{ ticker }}';
        const expirationDate = document.getElementById('expiration-date').value;
        const strikeMin = document.getElementById('strike-min').value;
        const strikeMax = document.getElementById('strike-max').value;
        const optionType = document.getElementById('option-type').value;

        const filters = {
            ticker: ticker,
            expiration_date: expirationDate,
            strike_price_range: strikeMin && strikeMax ? [parseFloat(strikeMin), parseFloat(strikeMax)] : null,
            option_type: optionType
        };

        fetch('/get_options_data', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(filters)
        })
        .then(response => response.json())
        .then(data => {
            if (!data.error) {
                populateTable('calls-table-body', data.calls, 'call', expirationDate);
                populateTable('puts-table-body', data.puts, 'put', expirationDate);
            }
        });
      });

      function populateTable(tableBodyId, data, optionType, expirationDate) {
        const tableBody = document.getElementById(tableBodyId);
        tableBody.innerHTML = '';  // Clear the table body

        data.forEach(option => {
            const expiration = new Date(expirationDate).toLocaleDateString('en-US') + ', 11:59:59 PM';
            const graphId = `${option.contractSymbol}-${option.strike}-${expiration}-${optionType}-graph`;
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${option.contractSymbol}</td>
                <td>${new Date(option.lastTradeDate).toLocaleString()}</td>
                <td>${option.strike}</td>
                <td>${option.lastPrice}</td>
                <td>${option.bid}</td>
                <td>${option.ask}</td>
                <td>${option.change}</td>
                <td>${option.percentChange}</td>
                <td>${option.volume}</td>
                <td>${option.openInterest}</td>
                <td>${option.impliedVolatility}%</td>
                <td>
                  <!-- Buy Button -->
                  <button class="btn btn-success" onclick="addToCart('${option.contractSymbol}', ${option.strike}, '${optionType}', '${expiration}', 'buy')">Buy in Cart</button>
                  
                  <!-- Sell Button -->
                  <button class="btn btn-danger" onclick="addToCart('${option.contractSymbol}', ${option.strike}, '${optionType}', '${expiration}', 'sell')">Sell in Cart</button>
                  
                  <!-- Toggle Graph Button -->
                  <button class="btn btn-secondary" onclick="toggleProfitGraph(this, '${option.contractSymbol}', ${option.strike}, '${optionType}', '${expiration}', '${graphId}')">Toggle Graph</button>

                  <!-- Add to Strategy Button -->
                  <button class="btn btn-primary" id="strategy-btn-${option.contractSymbol}" onclick="toggleOptionInStrategy(this, '${option.contractSymbol}', ${option.strike}, '${optionType}', '${expiration}')">+</button>
                </td>
            `;
            tableBody.appendChild(row);

            // Add an expandable row for each contract
            const expandableRow = document.createElement('tr');
            expandableRow.innerHTML = `
                <td colspan="12">
                    <div id="${graphId}" class="expandable-content"></div>
                </td>
            `;
            tableBody.appendChild(expandableRow);
        });
      }

      function updateStrategyContractsTable() {
        const strategyContractsBody = document.getElementById('strategyContractsBody');
        strategyContractsBody.innerHTML = '';  // Clear existing content

        strategy.forEach(contract => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${contract.contractSymbol}</td>
                <td>${contract.strike}</td>
                <td>${contract.optionType}</td>
                <td>${contract.expiration}</td>
            `;
            strategyContractsBody.appendChild(row);
        });
    }   

      function toggleOptionInStrategy(button, contractSymbol, strike, optionType, expiration) {
          const contractId = contractSymbol;
          if (addedContracts.has(contractId)) {
              // Remove from strategy
              strategy = strategy.filter(option => option.contractSymbol !== contractSymbol);
              addedContracts.delete(contractId);
              button.classList.remove('glow');  // Remove glow effect
          } else {
              // Add to strategy
              strategy.push({
                  contractSymbol: contractSymbol,
                  strike: strike,
                  optionType: optionType,
                  expiration: expiration
              });
              addedContracts.add(contractId);
              button.classList.add('glow');  // Add glow effect
          }

          if (strategy.length === 0) {
              toggleStrategyVisibility(false);
          } else {
              toggleStrategyVisibility(true);
              updateStrategyGraph();
              updateStrategyContractsTable();
          }
      }

      function buyStrategy() {
        
        const strategyName = document.getElementById('strategy-name').value;

        if (!strategyName) {
            alert('Please enter a name for your strategy.');
            return;
        }
    
        const strategyData = strategy.map(contract => ({
            contract: contract.contractSymbol,
            strike: contract.strike,
            expiration: contract.expiration,
            option_type: contract.optionType,
            action: 'buy',  // Assuming we are only buying strategies
        }));

        // Add the strategy as a whole to the cart
        fetch('/add_to_cart', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ strategy: strategyData, name: strategyName, type: 'strategy'})
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                alert('Strategy added to cart successfully!');
            } else {
                alert('Failed to add strategy to cart.');
            }
        })
        .catch(error => {
            console.error('Error adding strategy to cart:', error);
        });
    }

      function toggleProfitGraph(button, ticker, strike, type, expiration, graphId) {
        console.log(`Toggle graph clicked for: ${ticker} ${strike} ${type} ${expiration}`); 
    const expandableContent = document.getElementById(graphId);

    if (expandableContent.innerHTML !== '') {
        expandableContent.innerHTML = '';  // Collapse graph
    } else {
        const expandableTemplate = document.getElementById('expandable-template').content.cloneNode(true);
        expandableContent.appendChild(expandableTemplate);

        const graphContainer = expandableContent.querySelector('.graph-container');
        const detailsTable = expandableContent.querySelector('.details-table');
        
        const payload = { ticker, strike, expiration, type };
        console.log(`Payload for graph:`, payload);

        fetch('/get_option_profit_data', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        })
        .then(response => {
        console.log('Received response:', response);
        return response.json();
        })
        .then(data => {
            console.log('Received data:', data);
            if (!data.error) {
                const { stock_price_range_losses, profits_losses, stock_price_range_gains, profits_gains, annotations } = data;
                
                // Define losses (below breakeven) and gains (above breakeven)
                let lossesTrace, gainsTrace;

                if (type === 'put') {
                    // For put options, we expect profits to be when prices decrease
                    gainsTrace = {
                        x: stock_price_range_losses,  // Profits in green when prices go down
                        y: profits_losses,
                        mode: 'lines',
                        name: 'Gains',
                        line: { color: 'green', width: 2 }
                    };

                    lossesTrace = {
                        x: stock_price_range_gains,  // Losses in red when prices go up
                        y: profits_gains,
                        mode: 'lines',
                        name: 'Losses',
                        line: { color: 'red', width: 2 }
                    };
                } else {
                    // For call options, profits occur when prices rise
                    lossesTrace = {
                        x: stock_price_range_losses,  // Losses in red when prices go down
                        y: profits_losses,
                        mode: 'lines',
                        name: 'Losses',
                        line: { color: 'red', width: 2 }
                    };

                    gainsTrace = {
                        x: stock_price_range_gains,  // Profits in green when prices go up
                        y: profits_gains,
                        mode: 'lines',
                        name: 'Gains',
                        line: { color: 'green', width: 2 }
                    };
                }

                // Breakeven point marker
                const breakevenData = {
                    x: [annotations.breakeven.price],
                    y: [0],
                    mode: 'markers+text',
                    name: 'Breakeven',
                    text: ['Breakeven'],
                    textposition: 'top center',
                    marker: { color: 'blue', size: 10 }
                };

                // Plot the data
                Plotly.newPlot(graphContainer, [lossesTrace, gainsTrace, breakevenData]);

                graphContainer.style.display = 'block';  // Show the graph

                // Update hover event to show current stock price in details
                graphContainer.on('plotly_hover', function(data) {
                    const stockPrice = data.points[0].x;
                    detailsTable.querySelector('.current-stock-price').textContent = stockPrice.toFixed(2);
                });

                // Update details table with max profit, max loss, and breakeven info
                detailsTable.querySelector('.max-profit').textContent = annotations.max_profit.text;
                detailsTable.querySelector('.max-loss').textContent = annotations.max_loss.text;
                detailsTable.querySelector('.breakeven-price').textContent = annotations.breakeven.price.toFixed(2);

                detailsTable.style.display = 'block';  // Show the details table
            }
        });
    }
}


function updateStrategyGraph() {
    if (strategy.length === 0) {
        alert('Please add some options to the strategy.');
        return;
    }

    console.log(strategy);

    fetch('/get_combined_strategy_profit_data', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(strategy)
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            console.error('Error generating strategy graph:', data.error);
            alert('Error generating strategy graph. Check the console for details.');
        } else {
            const stockPriceRange = data.stock_price_range;
            const cumulativeProfits = data.cumulative_profits;

            // Calculate max profit and max loss
            const maxProfit = Math.max(...cumulativeProfits);
            const maxLoss = Math.min(...cumulativeProfits);

            // Identify breakeven points (where profit/loss intersects the x-axis)
            const breakevenPoints = [];
            const profitData = [];
            const lossData = [];

            for (let i = 1; i < stockPriceRange.length; i++) {
                const prevProfit = cumulativeProfits[i - 1];
                const currProfit = cumulativeProfits[i];
                const stockPrice = stockPriceRange[i];

                // Detect breakeven point
                if (prevProfit * currProfit < 0) {
                    const breakevenStockPrice = stockPriceRange[i - 1] + 
                        ((0 - prevProfit) / (currProfit - prevProfit)) * (stockPriceRange[i] - stockPriceRange[i - 1]);
                    breakevenPoints.push(breakevenStockPrice);

                    // Add the breakeven point to both profitData and lossData for smooth transition
                    profitData.push({ x: breakevenStockPrice, y: 0 });
                    lossData.push({ x: breakevenStockPrice, y: 0 });
                }

                // Separate the points into profit (>=0) and loss (<0)
                if (currProfit >= 0) {
                    profitData.push({ x: stockPrice, y: currProfit });
                    lossData.push({ x: stockPrice, y: null });  // Ensure no loss point at profit range
                } else {
                    lossData.push({ x: stockPrice, y: currProfit });
                    profitData.push({ x: stockPrice, y: null });  // Ensure no profit point at loss range
                }
            }

            // Create traces for profit and loss with no overlap at breakeven points
            const gainsTrace = {
                x: profitData.map(d => d.x),
                y: profitData.map(d => d.y),
                mode: 'lines',
                name: 'Profit',
                line: { color: 'green', width: 2 }
            };

            const lossesTrace = {
                x: lossData.map(d => d.x),
                y: lossData.map(d => d.y),
                mode: 'lines',
                name: 'Loss',
                line: { color: 'red', width: 2 }
            };

            // Breakeven points (show breakeven markers at x-axis intersections)
            const breakevenTrace = {
                x: breakevenPoints,
                y: Array(breakevenPoints.length).fill(0), // Zero profit at breakeven
                mode: 'markers+text',
                name: 'Breakeven',
                marker: { color: 'blue', size: 10 }
            };

            const layout = {
                title: 'Combined Strategy Profit/Loss',
                xaxis: { title: 'Stock Price' },
                yaxis: { title: 'Profit/Loss ($)' }
            };

            // Plot both profit and loss traces along with the breakeven points
            Plotly.newPlot('strategyGraph', [gainsTrace, lossesTrace, breakevenTrace], layout);

            document.getElementById('strategyGraph').style.display = 'block';  // Show strategy graph

            // Update the strategy details panel with max profit, max loss, and breakeven prices
            const strategyDetailsTable = document.querySelector('.strategy-details-table');
            strategyDetailsTable.querySelector('.strategy-max-profit').textContent = `$${maxProfit.toFixed(2)}`;
            strategyDetailsTable.querySelector('.strategy-max-loss').textContent = `$${maxLoss.toFixed(2)}`;
            strategyDetailsTable.querySelector('.strategy-breakeven-prices').textContent = breakevenPoints.join(', ');

            strategyDetailsTable.style.display = 'block';  // Show the strategy details table

            // Add hover functionality to update current stock price
            const graphContainer = document.getElementById('strategyGraph');
            graphContainer.on('plotly_hover', function(data) {
                const stockPrice = data.points[0].x;
                strategyDetailsTable.querySelector('.strategy-current-stock-price').textContent = stockPrice.toFixed(2);
            });
        }
    })
    .catch(error => console.error('Error fetching strategy profit data:', error));
}



    
      document.addEventListener('DOMContentLoaded', function() {
          document.getElementById('apply-filters').click();  // Automatically apply filters on page load
      });
    </script>
    {% endblock %}
</body>
</html>




